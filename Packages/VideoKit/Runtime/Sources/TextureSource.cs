/* 
*   VideoKit
*   Copyright Â© 2024 NatML Inc. All Rights Reserved.
*/

#nullable enable

namespace VideoKit.Sources {

    using System;
    using UnityEngine;
    using UnityEngine.Rendering;
    using Clocks;
    using Internal;

    /// <summary>
    /// Media source for generating images from textures.
    /// Images will be generated by performing a synchronous pixel buffer readback on the texture.
    /// </summary>
    public sealed class TextureSource : IDisposable {

        #region --Client API--
        /// <summary>
        /// Texture to automatically capture images from.
        /// When this is set, the source will generate images in the application update loop.
        /// To manually capture images, set this to `null` and use the `Append` method.
        /// </summary>
        public Texture? texture;

        /// <summary>
        /// Watermark image.
        /// If `null`, no watermark will be rendered.
        /// </summary>
        public Texture? watermark;

        /// <summary>
        /// Watermark display rect in pixel coordinates of the recorder.
        /// </summary>
        public RectInt watermarkRect;

        /// <summary>
        /// Crop rect in pixel coordinates of the recorder.
        /// </summary>
        public RectInt cropRect;

        /// <summary>
        /// Control number of successive frames to skip while generating images.
        /// This is very useful for GIF recording, which typically has a lower framerate appearance.
        /// </summary>
        public int frameSkip;
        
        /// <summary>
        /// Create a texture source.
        /// </summary>
        /// <param name="recorder">Media recorder to receive images.</param>
        /// <param name="clock">Clock for generating image timestamps.</param>
        public TextureSource (MediaRecorder recorder, IClock? clock = null) : this(
            recorder.width,
            recorder.height,
            recorder.Append,
            clock
        ) { }

        /// <summary>
        /// Create a texture source.
        /// </summary>
        /// <param name="width">Image width.</param>
        /// <param name="height">Image height.</param>
        /// <param name="handler">Handler to receive images.</param>
        /// <param name="clock">Clock for generating image timestamps.</param>
        public TextureSource (int width, int height, Action<PixelBuffer> handler, IClock? clock = null) {
            this.handler = handler;
            this.clock = clock;
            this.descriptor = new RenderTextureDescriptor(width, height, RenderTextureFormat.ARGB32, 0) {
                sRGB = true
            };
            this.cropRect = new RectInt(0, 0, width, height);
            VideoKitEvents.Instance.onFrame += OnFrame;
        }

        /// <summary>
        /// Append a pixel buffer from a texture.
        /// </summary>
        /// <param name="texture">Texture to readback from.</param>
        /// <param name="timestamp">Pixel buffer timestamp in nanoseconds.</param>
        public void Append (Texture texture, long timestamp = 0L) {
            // Check handler
            if (handler == null)
                return;
            // Blit
            var renderTexture = RenderTexture.GetTemporary(descriptor);
            Graphics.Blit(texture, renderTexture);
            // Readback
            if (SystemInfo.supportsAsyncGPUReadback)
                AsyncGPUReadback.Request(renderTexture, 0, TextureFormat.RGBA32, request => {
                    // Check handler
                    if (handler == null)
                        return;
                    // Check error // Thanks Dr. Arth!
                    if (request.hasError) {
                        Debug.LogWarning("VideoKit TextureSource failed to readback texture data");
                        return;
                    }
                    // Invoke handler
                    using var pixelBuffer = new PixelBuffer(
                        request.width,
                        request.height,
                        PixelBuffer.Format.RGBA8888,
                        request.GetData<byte>(),
                        timestamp: timestamp
                    );
                    handler(pixelBuffer);
                });
            else {
                // Readback
                readbackBuffer = readbackBuffer != null ?
                    readbackBuffer :
                    new Texture2D(descriptor.width, descriptor.height, TextureFormat.RGBA32, false);
                var prevActive = RenderTexture.active;
                RenderTexture.active = renderTexture;
                readbackBuffer.ReadPixels(new Rect(0, 0, descriptor.width, descriptor.height), 0, 0, false);
                // Invoke handler
                using var pixelBuffer = new PixelBuffer(
                    descriptor.width,
                    descriptor.height,
                    PixelBuffer.Format.RGBA8888,
                    readbackBuffer.GetRawTextureData<byte>(),
                    timestamp: timestamp
                );
                handler(pixelBuffer);
                // Reassign
                RenderTexture.active = prevActive;
            }
            // Release
            RenderTexture.ReleaseTemporary(renderTexture);
        }

        /// <summary>
        /// Stop the media source and release resources.
        /// </summary>
        public void Dispose () {
            handler = null;
            VideoKitEvents.Instance.onFrame -= OnFrame;
            Texture2D.Destroy(readbackBuffer);
        }
        #endregion


        #region --Operations--
        private Action<PixelBuffer>? handler;
        private readonly IClock? clock;
        private readonly RenderTextureDescriptor descriptor;
        private int frameIdx;
        private Texture2D? readbackBuffer;

        private void OnFrame () {
            // Check texture
            if (texture == null)
                return;
            // Check frame index
            if (frameIdx++ % (frameSkip + 1) != 0)
                return;
            // Crop
            var cropDest = RenderTexture.GetTemporary(descriptor);
            ApplyCrop(texture, cropRect, cropDest);
            // Watermark
            var watermarkDest = RenderTexture.GetTemporary(descriptor);
            ApplyWatermark(cropDest, watermark, watermarkRect, watermarkDest);
            // Append
            Append(watermarkDest, clock?.timestamp ?? 0L);
            // Release
            RenderTexture.ReleaseTemporary(cropDest);
            RenderTexture.ReleaseTemporary(watermarkDest);
        }

        private static void ApplyCrop (Texture source, RectInt rect, RenderTexture destination) {
            // Compute crop scale
            var frameSize = new Vector2(destination.width, destination.height);
            var ratio = new Vector2(frameSize.x / rect.width, frameSize.y / rect.height);
            var scale = Mathf.Max(ratio.x, ratio.y);
            // Compute draw rect
            var pixelSize = scale * frameSize;
            var minPoint = 0.5f * frameSize - scale * rect.center;
            var maxPoint = minPoint + pixelSize;
            var drawRect = new Rect(minPoint.x, destination.height - maxPoint.y, pixelSize.x, pixelSize.y);
            // Render
            var prevActive = RenderTexture.active;
            RenderTexture.active = destination;
            GL.Clear(true, true, Color.black);
            GL.PushMatrix();
            GL.LoadPixelMatrix(0, destination.width, destination.height, 0);
            Graphics.DrawTexture(drawRect, source);
            GL.PopMatrix();
            RenderTexture.active = prevActive;
        }

        private static void ApplyWatermark (Texture source, Texture? watermark, RectInt rect, RenderTexture destination) {   
            // Render source         
            var drawRect = new Rect(rect.x, destination.height - rect.max.y, rect.width, rect.height);
            var prevActive = RenderTexture.active;
            RenderTexture.active = destination;
            GL.Clear(true, true, Color.black);
            GL.PushMatrix();
            GL.LoadPixelMatrix(0, destination.width, destination.height, 0);
            Graphics.Blit(source, destination);
            // Render watermark
            if (watermark)
                Graphics.DrawTexture(drawRect, watermark);
            // Restore
            GL.PopMatrix();
            RenderTexture.active = prevActive;
        }
        #endregion
    }
}